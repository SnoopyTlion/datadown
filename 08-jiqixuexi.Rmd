# 统计模型 {#mlsl}

## 统计学习概论

- 统计学习：理解数据的工具集
- 监督学习：有因变量，根据自变量预测估计因变量
- 非监督学习：无因变量，探索自变量间的关系与结构

## 统计学习简史

- 19世纪初，Legendre 与 Gauss 发表了最小二乘法的论文，该方法首先应用在天文学领域
- 1936年，Fisher 提出线性判别分析来解决定性分析问题
- 1940s，logistic回归提出
- 1970s，Nelder 与 Wedderburn 提出广义线性模型，将线性回归与logistic回归统一到一个体系
- 1980s，计算机技术进步，非线性问题开始得到解决
- Breiman，Friedman，Olshen 与 Stone 提出回归树与聚类，提供交叉检验方法
- 1986年，Hastie 与 Tibshirani 提出广义加性模型，将广义线性模型与一些非线性模型同一到一个体系
- 伴随软件，机器学习与其他理论的发展，统计学习作为统计学子学科快速发展

## 统计学习定义

- $Y = f(X) + \epsilon$
- 统计学习本质上是在寻找最合适的f来进行**预测**与**推断**

## 预测 

- $\hat Y = \hat f(X)$，$\hat f(X)$ 通常看作黑箱
- $\hat Y$预测$Y$需要考虑两部分误差：可约误差与不可约误差
- 可约误差指$\hat f$推断$f$上的偏差
- 不可约误差指由$\epsilon$引入的误差
- 误差的期望 $E(Y - \hat Y)^2 = [f(x) - \hat f(x)]^2 + Var(\epsilon)$ (证明用到$E(Y)$)

## 推断

- 关注X与Y的关系，$\hat f(X)$ 通常有明确的形式
- 自变量因变量是否相关
- 如何相关
- 关系的数学描述

## 估计模型

- 使用训练集与验证集
- 参数方法与非参数方法
- 模型的欠拟合与过拟合，回归模型低方差高偏差，邻近聚类高方差低偏差
- 权衡模型的准确性（预测）与可解释性（推断）
- 模型的奥卡姆剃刀与黑箱

## 评价模型

### 拟合质量测量

- 训练集均方误 $MSE_{Tr} = Ave_{i \in Tr}[y_{i} − \hat f(x_i)]^2$
- 测试集均方误 $MSE_{Te} = Ave_{i \in Te}[y_{i} − \hat f(x_i)]^2$
- 测试集均方误源于训练集拟合模型的方差，误差项$\epsilon$的方差及模型误差的平方三部分

### 聚类评价

- 错误率 $Err_{Te} = Ave_{i \in Te}I[y_i \neq \hat C(x_i)]$
- 贝叶斯分类器：错误率最小的分类器，使x属于某个分类的概率最大
- k临近值聚类：距离最小的k个为一类所产生的分类器

- 问题 -> 数据 -> 特征 -> 算法 -> 参数 -> 评价

> The combination of some data and an aching desire for an answer does not ensure that a reasonable answer can be extracted from a given body of data. John Tukey

- 数据质量优先于模型
- 不要自动特征选择
- 算法的可扩展性与计算性能要考虑
- 数据过拟合问题 数据总是由信号与噪音组成 但会被算法无差别对待
- 数据要与问题相关 低相关度的组合可能产生高相关度

## 研究设计

- 定义错误率
- 将数据分割为训练集 预测集 验证集
- 在训练集上使用交叉检验选择特征与预测算法
- 在预测集或验证集上使用一次数据
- 预测效果起码要优于瞎猜
- 避免使用小样本
- 比例为 60% 训练集 20% 预测集 20% 验证集 或 60% 训练集 40% 预测集 或小样本交叉检验
- 注意数据结构 时序分析要对数据分段采样

## 错误率

- 真阳性 真的是对的 TP
- 假阳性 真的是错的 FP Type I
- 真阴性 假的是错的 TN
- 假阴性 假的是对的 FN Type II
- 灵敏度 TP/(TP+FP)
- 特异性 TN/(TN+FN)
- 均方差 MSE $\frac{1}{n} \sum_{i=1}^n (Prediction_i - Truth_i)^2$
- 均方误 RMSE $\sqrt{\frac{1}{n} \sum_{i=1}^n(Prediction_i - Truth_i)^2}$
- 中位差 Median absolute deviation
- 准确性 (TP+TN)/(TP+FP+TN+FP)
- 一致性 [kappa值](https://en.wikipedia.org/wiki/Cohen%27s_kappa)

## ROC 曲线

- 分类问题寻找判别阈值 满足一定TP下最小FP的模型
- FP v.s.TP 作图
- AUC 曲线下面积表示选择标准 一般超过80%
- 对角线是随机猜的结果


## 重采样技术

### 交叉检验

- 训练集上的操作
- 训练集上再分为训练集与测试集
- 在测试集上评价 重复并平均化测试集错误
- 用来进行变量 模型 参数选择
- 随机 分组 留一
- 分组多方差大 分组少有偏差
- 有放回的为bootstrap 不建议用

- 核心思想：通过保留一部份训练集数据作为检验集来估计真实检验集的错误率与模型拟合效果
- 验证集方法：将训练集数据分为两部分，一部份拟合模型，一部份检验模型，这样得到的错误率为真实检验集的一个估计，选取错误率较低的模型建模
- 验证集方法缺点：错误率依赖于采样变动较大，训练集少，高估了错误率
- 留一法(LOOCV)：每次建模留一个数据点作为验证集，$MSE_i = (y_i - \hat y_i)^2$重复n次，得到一个CV值作为对错误率的估计:$CV_{(n)} = \frac{1}{n} \sum_{i = 1}^{n} MSE_i$
- 留一法优点：使用数据量大，偏差小；结果唯一，不受随机化影响
- 留一法缺点：计算量大，公式插入杠杆统计量调节杠杆点对方程拟合的影响，得到$CV_{(n)} = \frac{1}{n} \sum_{i = 1}^{n} (\frac{y_i - \hat y_i}{1 - h_i})^2$
- k叠交叉检验：将训练集分为k叠，每次建模用(k-1)叠，用1叠检验
- k叠交叉检验优点：计算量小，结果与留一法相差不多- 交叉检验的结果用来寻找$CV$值最小的点来选择模型，通常与真实检验集最小点结果相差不大乎，但交叉检验给出的$MSE$会偏低
- 偏差方差权衡：使用的训练集数据越多，估计偏差越小，方差越大（相关性越高的方差越大）
- 分类问题使用错误率计算$CV$：$CV{(n)} = \frac{1}{n} \sum_{i = 1}^{n} Err_{i}$
- *少n多p问题上使用交叉检验，不可先进行全模型变量选择再交叉检验，应该对整个过程交叉检验*

### bootstrap

- 在训练集里有放回的重采样等长的数据形成新的数据集并计算相关参数，重复n次得到对参数的估计，计算标准误
- 生成Bootstrap Percentile置信区间
- 适用于独立样本，样本间有相关如时间序列数据可采用block法分组屏蔽掉进行bootstrap
- 因为存在重复，使用bootstrap建立训练集与预测集会有非独立样本，造成检验集模型方差的低估，去掉重复使模型复杂，不如交叉检验对检验集误差估计的准
- [slipper 包](https://github.com/jtleek/slipper)

## `caret` 包

- 数据清洗 预处理
- 数据分割 `createDataPartition` 数据比例 重采样 产生时间片段
- 训练检验整合函数 `train` `predict` 
- 模型对比 
- 算法整合为选项 线性判别 回归 朴素贝叶斯 支持向量机 分类与回归树 随机森林 Boosting 等

## 数据分割

- `train <- createDataPartition(y=spam$type,p=0.75, list=FALSE)` 数据三一分 得到index
- `folds <- createFolds(y=spam$type,k=10,list=TRUE,returnTrain=TRUE)` 数据分10份 返回每一份列表
- `folds <- createResample(y=spam$type,times=10,list=TRUE)` 数据bootstrap重采样 返回每一份列表
- `folds <- createTimeSlices(y=tme,initialWindow=20,horizon=10)` 时序数据重采样 产生20为窗口时序片段的训练集与预测集

## 训练选项

- `args(train.default)` 通过 `method` 控制算法 `metric` 控制算法评价 `trainControl` 控制训练方法
- `trainControl`中 `method`选择模型选择方法 如bootstrap 交叉检验 留一法 `number` 控制次数 `repeats` 控制重采样次数 `seed` 控制可重复性 总体设置一个 具体每一次用列表设置控制具体过程 特别是并行模型

## 预测变量作图

- `featurePlot` 
- `ggplot2`

## 数据预处理

- `train` 中的 `preProcess=c("center","scale")` 标准化
- `spatialSign` 该转化可提高计算效率 有偏
- `preProcess(training[,-58],method=c("BoxCox"))` 正态化转化
- `method="knnImpute"` 用最小邻近法填补缺失值
- `nearZeroVar` 去除零方差变量
- `findCorrelation` 去除相关变量
- `findLinearCombos` 去除线性组合变量
- `classDist` 测定分类变量的距离 生成新变量
- 测试集也要预处理

## 协变量生成

- 原始数据提取特征
- 提取特征后生成新变量
- 因子变量要转为虚拟变量
- 样条基变量 `splines` 包中的 `bs`
- 数据压缩 `preProcess` 中 `method` 设置为 `pca` `pcaComp` 指定主成分个数

## 线性回归&多元线性回归

- $ED_i = b_0 + b_1 WT_i + e_i$ 基本模型
- 参见前面回归部分

### 简单线性回归

- $Y \approx \beta_0 + \beta_1 X$
- 用最小二乘法估计$\beta_0$与$\beta_1$得到估计值$\hat \beta_0$与$\hat \beta_1$，代入$X$，得到模型估计值$\hat Y$
- 残差平方和：$RSS = e_1^2 + e_2^2 + ... + e_n^2$，使RSS最小，求导可得参数
- 回归线不等于最小二乘线，最小二乘线是通过采样对回归线的估计
- 估计会存在偏差，均值的偏差用标准误来描述$Var(\hat \mu) = SE(\mu)^2 = \frac{\sigma^2}{n}$
- 回归参数的估计也涉及标准误的计算$Var(\beta_{1}) = \frac{\sigma^2}{\sum_{i=1}^n{(x_i - \bar{x})^2}}$
- $\sigma^2$可用残差标准误RSE($RSE = RSS/(n − 2)$)来估计$\qquad\hat\sigma^2 = \frac{n-p}{n}\;s^2$
- 据此可得回归参数的95%置信区间$\hat \beta_1 ± 2 \cdot SE(\hat \beta_1)$
- 参数的评价可通过假设检验进行，零假设为$\beta_1$为0，也就是自变量对因变量无影响，构建t统计量$t = \frac{\hat \beta_1 - 0}{\hat {SE}(\hat \beta_1)}$，然后可根据p值判断参数的显著性
- 评价参数后需要评价模型，主要通过$RSE$与$R^2$来进行
- $R^2$表示模型所解释总体方差的比例，与$RSE$不同，独立于Y，$R^2 = \frac{TSS - RSS}{TSS}$
- $R^2$与两变量间的相关系数是一致的，但$R^2$统计量的应用面要广于相关系数
- 相关系数也可进行假设检验进而判断相关的显著性

### 多元线性回归

- 通过统计量F检验确定回归是否显著，零假设为所有自变量系数为0 $F = \frac{(TSS - RSS)/p}{RSS/(n-p-1)}$
- 变量选择：向前选择（从0个到p个，显著则包含），向后选择（从p个到0个，不显著则剔除），混合选择（通过p的阈值调节）
- 因为RSS会减少，$R^2$会伴随自变量数目的增加而增加
- $RSE$在多元线性线性回归中为$RSE = RSS/(n − p - 1)$，伴随自变量个数增加影响超过$RSS$减少的影响，$RSE$会增大
- 自变量间的影响会导致相比单一变量预测更容易出现不显著，这说明自变量间有可能可相互解释
- 预测的置信区间与预测区间，前者指模型的变动范围，后者指某个预测值的变动范围，考虑真值本身的变动，后者大于前者
- 因子变量通过对每个水平添加系数0，1来回归，也可根据需要赋值

### 线性模型延拓

- 线性模型基本假设：可加性与线性
- 去掉可加性：考虑交互作用
- 层级原理：交互作用项显著而主作用不显著时不可去掉主作用项
- 去掉线性：多项式回归

### 常见问题

- 关系非线性：残差图判断
- 误差项共相关：误差项的相关会导致标准误估计偏低，低估参数的区间使不显著差异变得显著，考虑时间序列数据，观察误差项轨迹判断
- 误差项方差非常数：喇叭状残差图，通过对因变量进行对数或开方来收敛方差，或者用加权最小二乘
- 异常值：通过标准化残差图判断
- 杠杆点：加入后会影响模型拟合，通过杠杆统计量判断： $h_i = \frac{1}{n} + \frac{(x_i - \bar x)^2}{\sum_{i' = 1}^{n} (x_i' - \bar x)^2}$ 多元回归中该统计量均值为$(p+1)/n$，超过很多则可能为杠杆点
- 在标准残差-杠杆值图中，右上或右下方为危险值，左方数值对回归影响不大
- 共线性：共线性的变量相互可替代，取值范围扩大，标准误加大，对因变量影响相互抵消，降低参数假设检验的功效
- 多重共线性：引入方差膨胀因子，自变量引入全模型与单一模型方差的比值，超过5或10说明存在共相关，$VIF(\hat \beta_j) = \frac{1}{1 - R^2_{X_j|X_{-j}}}$
- 解决共线性：丢弃变量或合并变量
- 共线性不同于交互作用

### 线性回归与kmeans算法比较

- k临近算法：$\hat f(x_0) = \frac{1}{K} \sum_{x_i \in N_0} y_i$ 核心是选择k
- KNN算法在解决非线性问题上有优势，但一样的面对高维诅咒
- 线性回归可给出可解释的形式与简单的描述

### logistic回归

- 因变量以概率形式出现
- $p(X) = \frac {e^{\beta_0 + \beta_1 X}}{1 + e^{\beta_0 + \beta_1 X}}$
- 变形后$\frac {p(X)}{1 - p(X)}$ 为胜率，比概率应用更实际些，去对数后为对数胜率（logit）
- 因变量$p(X)$与自变量间关系非线性
- 用极大似然估计确定参数，似然函数为$l(\beta_0, \beta_1) = \prod_{i:y_i = 1} p(x_i)\prod_{i':y_{i'} = 0} (1 - p(x_{i'}))$，该函数取最大值
- 线性回归中，最小二乘法为极大似然估计的特例
- 混杂因素的解释上要考虑单因素回归与多元回归
- 多响应logistic回归一般被判别分析取代

### 线性判别分析

- 使用原因：分类离散时logistic回归不稳定，n小X正态时更稳定，适用于多响应
- 贝页斯理论：$Pr(Y = k|X = x) = \frac{\pi_k f_k(x)}{\sum_{l = 1}^K \pi_lf_l(x)}$ 其中$\pi$ 代表先验概率，估计$f_k(X)$需要对$x$的分布作出假设
- 自变量为1时，假定$f_k(x)$分布为正态的，有$f_k(x) = \frac{1}{\sqrt{2 \pi} \sigma_k} exp(- \frac{1}{2 \sigma_k^2} (x - \mu_k)^2)$，代入可得$p_k(x)$，取对数有$\sigma_k(x) = x \cdot \frac{\mu_k}{\sigma^2} - \frac{\mu_k^2}{2\sigma^2} + log(\pi_k)$，使$\sigma_k(x)$最大的分类方法为判定边界
- 贝页斯分类器需要知道所有分布参数，实际中会采用线性判别分析（LDA），通过以下训练集估计方法来插入贝页斯分类器：$\hat \pi_k = n_k/n$、$\hat \mu_k = \frac{1}{n_k} \sum_{i:y_i = k} x_i$ 与 $\hat \sigma^2 = \frac{1}{n - K} \sum_{k = 1}^K \sum_{i:y_i = k} (x_i - \hat \mu_k)^2$
- 线性体现在判别函数$\hat \sigma_k(x)$的形式是线性的
- 自变量多于1时，假设自变量均来自多元正态分布的分类
- 列连表，表示假阳性，假阴性，可计算灵敏度与特异性
- LDA是对贝页斯分类的模拟，旨在降低总错误率，因此灵敏度与特异性区分并不明显，可根据实际需要调节
- ROC曲线用来展示两种错误，横坐标假阳性，纵坐标真阳性

### 二次判别分析（QDA）及其它

- 不同于LDA，二次判别分析考虑各分类参数中方差不同而不是相同，引入了二次项
- 对分类描述更为精细，但容易过拟合，样本较少，LDA优先
- 对比logistic回归，两者数学形式相近，取值上logistic回归使用极大似然法，LDA使用共方差的高斯分布假设，结论多数条件一致，但随假设不同而不同
- KNN更适用于非线性关系，标准化很有必要，QDA相对温和

### 线性模型选择与正则化

- 最小二乘法（OLS）容易解释，预测性能好，但不万能
- 预测准确性上，当p>n时，模型方差变大
- 模型解释上，p过多需要去除，进行模型选择

#### 子集选择

- 从p个自变量中选出与模型响应相关的进行建模
- 使用devianc，最大化为最优子集
- 最佳子集选择：p个自变量$p \choose k$ ，计算$RSS$与$R^2$，$RSS$要小，$R^2$要大，选择最佳的
- 步进法：p值过大，计算负担重，采用逐步改进法进行模型选择
- 向前步进选择：从0个自变量开始加，第k个自变量选择p-k个模型，如果$RSS$与$R^2$表现好就保留，递近选择变量，不保证选择最佳模型，p值较大优先考虑
- 向后步进选择：从p个自变量开始减，如果第k个自变量在模型$RSS$与$R^2$中没表现，就剔除进行变量选择，不保证选择最佳模型，适用于p值较小的情况(较大可能无法拟合)
- 步进选择构建$1 + p(p+1)/2$个模型，最佳子集法需要构建$2^p$个模型
- 混合模型:向前选择，之后向后验证，剔除不再提高效果的模型

#### 测试集误差估计

- $RSS$与$R^2$评价的是训练集拟合状况，不适用于估计测试集误差
- 估计测试集误差可以构建统计量调节训练集误差或直接通过验证集来估计
- Mallow’s $C_p$：$C_p = \frac{1}{n} (RSS + 2d\hat \sigma^2)$ $d$代表使用的变量数，$\hat \sigma^2$是对模型方差的估计
- AIC：$AIC = -2logL + 2 \cdot d$ 极大似然估计，线性模型下$C_p$与AIC实质等同
- BIC：$BIC = \frac{1}{n}(RSS + log(n)d\hat \sigma^2)$ n是样本数，大于7时BIC会比$C_p$选择更轻量的模型
- 调节$R^2$：$Adjusted$ $R^2 = 1 - \frac{RSS/n-d-1}{TSS/(n - 1)}$ 值越大，测试集误差越小
- 不同于$C_p$，AIC，BIC有严格的统计学意义，调节$R^2$虽然直观，但理论基础相对薄弱，单纯考虑了对无关变量的惩罚
- 验证与交叉验证：直接估计测试集误差而不用估计模型方差
- 单标准误原则：先计算不同规模测试集$MSE$的标准差，选择曲线中最小测试集误差一个标准误内最简单的模型

#### 收缩

- 对系数估计进行收缩，接近0或等于0进行变量选择

##### 岭回归

- 不同于最小二乘估计对$RSS$的最小化，岭回归最小化$RSS + \lambda \sum_{j = 1}^{p} \beta_j^2$，其中$\lambda$为调谐参数，后面一项为收缩惩罚，是个$l_2$范数，使参数估计逼近0，选择合适$\lambda$很重要，可用交叉检验来实现
- 因为范数大小影响模型惩罚项，所以进行岭回归前要做标准化处理$$\bar x_{ij} = \frac{x_{ij}}{\sqrt{\frac{1}{n} \sum_{i = 1}^n (x_{ij} - \bar x_j)^2}}$$
- 岭回归的参数$\lambda$与范数收缩状况可看作最小$MSE$的函数来表现偏差-误差均衡
- 岭回归适用于最小二乘回归产生方差较大的情况，同时，计算负担较小，只伴随$\lambda$取值范围变化而变化

##### Lasso

- 形式与岭回归一致，最小化$RSS + \lambda \sum_{j = 1}^{p} |\beta_j|$，使用$l_1$范数
- 岭回归参数同步收缩接近0，Lasso可以通过软边界直接收缩到0实现变量选择，产生稀疏模型，想像超球体与超多面体与超球面的接触
- 贝页斯视角下，岭回归与lasso关于线性模型系数的先验分布是不同的：前者为高斯分布，接近0时平坦，后验概率等同最优解；后者为拉普拉斯分布，接近0时尖锐，先验概率系数接近0，后验概率不一定为稀疏向量
- 岭回归与Lasso分别适用于真实模型自变量多或少的情况，并不广谱，考虑交叉检验来进行选择
- 交叉检验也可用来选择$\lambda$, 通过选择的自变量参与建模

#### 降维

- 前提是自变量间不独立，将p个自变量向量投影到M维空间(M < p)，使用投影M拟合线性回归模型 $\sum_{m = 1}^{M}\theta_m z_{im} = \sum_{m = 1}^{M} \theta_m \sum_{j = 1}^{p} \phi_{jm}x_{ij} = \sum_{j = 1}^p \sum_{m = 1}^{M} \theta_m \phi_{jm} x_{ij} = \sum_{j = 1}^{p} \beta_j x_{ij}$
- 主成分：各自变量在主成分方向上方差最大
- 主成分回归(PCA)：实际为无监督算法，得到主成分后作为新变量进行最小二乘回归，认为因变量与自变量变异最大的方向一致，需要仔细检验这个假设，主成分个数的选择影响模型效果
- 岭回归疑似为主成分回归的连续版，两者都需要标准化，效果也相近
- 偏最小二乘(PLA)：第一个投影方向为因变量与自变量回归方向，后续投影是对残差投影方向的回归，重复得到监督学习的效果
- PLA通常并不比PCA更好，引入了监督算法提高了偏差

#### 高维数据

- n远远少于p或接近的数据
- 最小二乘估计在n小于p时残差为0，太过精细
- $C_p$，AIC，BIC方法因为有参数$\hat \sigma^2$需要估计，而这个参数会在高维数据下变成0，调节$R^2$也会变成1
- 高维诅咒：正则化或收缩对高维方法产生影响，合适调谐参数十分重要，测试集误差必然增长
- 引入新变量会对预测产生不可知影响，选出的自变量并非不可替代，结果用独立验证集误差或交叉检验误差描述

## 非线性

### 多项式回归

- 模型基本形式为单一自变量在不同幂指数下的多项式，最小二乘拟合
- 模型在特定点的方差受系数方差与协方差影响，幂越高，模型越精细，方差越大
- 幂次一般不超过3或4
- 可进行logistic回归

### 阶梯函数

- 阶梯函数将自变量由连续变成有序分类变量
- 函数形式为引入指标函数$C_K(x)$进行自变量分段，然后进行最小二乘拟合
- 依赖找间隔点
- 可进行logistic回归

### 基函数

- 固定线性系数$\beta$,自变量的形式由$b(x)$决定，$b(x)$为基函数
- 多项式回归与阶梯函数均为基函数的特例

### 回归样条

- 设定分段点，分段点前后进行多项式回归
- K个点分割(K+1)段，存在(K+1)个多项式回归，自由度过高
- 进行边界约束，对n次方程而言，约束分段点0阶，1阶，2阶导数连续，减少3个自由度，共有K个点，则有$(n+1-3)k + n + 1$个自由度，相比无约束的$(n+1)k$，自由度减少，更稳健
- 一般而言约束限制为(自由度-1)阶连续，这样自由度比分界点略多些，够用
- 分段样条最好在两端加入线性限制，收敛自由度，这样在边界稳健，为自然样条
- 分段点位置一般均匀分布，个数（本质上是自由度）通过交叉检验来确定
- 分段多项式回归限定了自由度，因此结果一般比多项式回归更稳定

### 平滑样条

- 如果以RSS衡量不加入限制，很容易产生过拟合，因此考虑加入平滑项
- 最小化 $$ \sum_{i = 1}^n (y_{i} - g(x_i))^2 + \lambda \int g''(t)^2 dt $$ 其中，$g(x)$为平滑样条，由损失函数与惩罚项组成，二次导数表示在t处的平坦度，越平坦，惩罚越小，越崎岖，惩罚越大，因而平滑
- 对三次函数而言，平滑样条会将函数两端收敛的跟自然样条一样，实际上，平滑样条是自然样条的收缩版
- 参数$\lambda$也影响平滑效果，越大越平滑，因为k固定，只涉及$\lambda$的选择
- 参数$\lambda$的选择基于有效自由度，可以用留一法进行估计，形式与杠杆点统计量差不多，可以很方便的进行数值求解
- 平滑样条的自由度比多项式要小，更稳健

### 本地回归

- 首先分段，然后分段内进行加权回归，离某点越近，权重越高，进行最小二乘拟合，得到每个点的函数，联合模型拟合
- 自变量较多，可考虑本地有选择的选取自变量进行本地回归
- 同样遭受高维诅咒带来的临近值少或稀疏问题

### 广义加性模型

- $$y_i = \beta_0 + \sum_{i = 1}^n f_j(x_{ij}) + \epsilon$$ 每个自变量都有自己的函数形式，加合求解
- 每个自变量影响都可以展示
- 可分段，也可使用平滑，平滑方法中使用了反馈拟合策略对不易用最小二乘拟合求解的问题进行求解，效果差不多，分段不必要
- 可用于分类回归问题，解释性好
- 优点：非线性，更准确，易解释，可进行统计推断，可用自由度衡量平滑性
- 缺点：不易考虑交互影响


## 树

### 回归树

- 将因变量按自变量分区间，每个区间内预测值一致，直观易解释
- $\sum_{j = 1}^J\sum_{i \in R_J}(y_i - \hat y_{R_j})^2$
- 计算困难，使用自上而下的贪心算法
- 递归二元分割：构建树过程每个节点都选最佳分割点，也就是分割后残差最小的变量与数值
- 算法在叶样本数为5时结束
- 树修剪，选择训练集误差最小的子树，引入调谐因子$\alpha$
- 最小化$\sum_{m = 1}^{|T|} \sum_{i:x_i \in R_m} (y_i - \hat y_{R_m})^2 + \alpha|T|$ 类似lasso算法
- 确定$\alpha$要用交叉检验，之后选出特定模型

### 分类树

- 因变量为分类变量，RSS用分类错误率代替
- $E = 1 - max_k(\hat p_{mk})$但分类错误率对树生长并不敏感，应采用其他指标
- Gini系数：$G = \sum_{k = 1}^K\hat p_{mk}(1 - \hat p_{mk})$，分类越准，值越小，衡量端纯度
- cross-entropy：$D = - \sum_{k = 1}^K\hat  p_{mk} log\hat p_{mk}$，与Gini系数相似，描述一致
- 如果以修剪树为目标，指标应选择分类错误率
- 节点产生相同预测说明预测纯度不同，可靠性不同
- 与线性模型相比，适用数据种类不同，借助可视化判断
- 优点：容易解释，适用于决策，容易出图，处理分类问题简单
- 缺点：预测准确率低于其他常见回归与分类方法

### Bagging

- 决策树方法相比线性回归模型方差很大
- 引入Bootstrap，通过平均构建低方差模型
- $\hat f_{avg}(x) = \frac{1}{B} \sum_{b = 1}^B \hat f^{*b}(x)$ 
- 不修剪，通过平均降低方差
- 对于分类变量，通过投票，少数服从多数得到答案
- 误差估计通过包外样本（OOB）进行交叉检验并进行树的选择，降低计算成本
- 变量权重在Bagging中不易衡量，可通过衡量每棵树的RSS或者Gini系数在进行一次变量分割后RSS下降程度并进行排序取得
- 该方法可应用于其他统计模型

- 重采样 重新计算预测值
- 平均或投票给出结果
- 减少方差 偏差类似 适用于非线性过程
- bagged trees
  - 重采样
  - 重建树
  - 结果重评价
  - 更稳健 效果不如RF
- Bagged loess 可用来处理细节


### 随机森林

- bagging中使用所有的变量进行选择，但是会更易出现共相关变量，方差降低不多
- 随机森林的核心在于强制使用较少的自变量，为其他自变量提供预测空间进而提高模型表现
- 变量数一般选择为$\sqrt p$
- 表现会比bagging好一些
- bootstrap采样
- 每一个节点bootstrap选取变量
- 多棵树投票
- 准确度高 速度慢 不好解释 容易过拟合

### Boosting

- 通用的统计学习方法
- 树生长基于先前的树，不使用bootstrap，使用修改过的原始数据
- 先生成有d个节点的树，之后通过加入收缩的新树来拟合残差，收缩因子为$\lambda$，呈现层级模式，最后模型为$\hat f(x) = \sum_{b = 1}^B \lambda \hat f^b(x)$
- boosting学习缓慢，一般学习较慢的学习效果更好
- 三个参数：树个数B（交叉检验），收缩因子$\lambda$（控制学习速率），树节点数（一般为1，为交互作用深度，控制涉及变量）
- 深度d为1时是加性模型
- 随机森林与Boosting产生的模型都不好解释


- 迭代分割变量
- 在最大化预测时分割
- 评估分支的同质性
- 多个树的预测更好
  - 优点 容易解释应用 可用在神经网络上
  - 缺点 不容易交叉验证 不确定性不宜估计 结果可能变化
-算法
  - 先在一个组里用所有的变量计算
  - 寻找最容易分离结果的变量
  - 把数据按照该变量节点分为两组
  - 在每一个组中寻找最好的分离变量
  - 迭代直到过程结束    
  - 节点纯度用 Gini 系数或 交叉墒来衡量
- `rattle` 包的 `fancyRpartPlot` 出图漂亮
- 可用来处理非线性模型与变量选择

- 弱预测变量加权后构建强预测变量
- 从一组预测变量开始
- 添加有惩罚项的预测变量来训练模型
- 以降低训练集误差为目的
- 通用方法

## 支持向量机

### 最大边界分类器

#### 超平面

- p维空间里(p-1)维子空间
- $\beta_0 + \beta_1 X_1 + \beta_2 X_2 + ... + \beta_p X_p = 0$ 定义一个p维超平面，X落在超平面上
- p维空间中点X不在超平面上就在其两侧

#### 超平面分类

- n*p矩阵X分为两类Y-1或1
- 代入超平面大于0为1，小于0为-1，有$Y*\beta*X > 0$ 表示分类正确
- 构建训练函数$f(x^*) = \beta_0 + \beta_1 X_1^* + \beta_2 X_2^* + ... + \beta_p X_p^*$ 正数表示为1，负数为-1，距离0越远表示距离超平面越远，越近表示分类越不确定，判定边界为线性

#### 最大边界分类器

- 最大边界超平面：距离边界最近的距离的所有超平面中距离边界点最远的那个超平面
- 分类良好但容易在p大时过拟合
- 形成最大边界分类器所需要的边界点为支持向量，用以支持最大边界超平面
- $f(x^*)*y_i$在系数平方和为1时为点到平面的垂直距离，最小化后最大化这个距离是求最大边界超平面的关键

### 支持向量分类器

- 有些情况不存在超平面，需要求一个软边界来适配最多的分类，这就是支持向量分类器
- 因为是软边界所以允许在超平面或边界一边出现误判
- 计算上还是为最小化最大化距离，但分类上距离要乘以$1 - \epsilon_i$项，也就是松弛变量
- 松弛变量大于0表示边界误判，大于1表示超平面误判，总和为C，表示边界的容忍度，越大分类越模糊
- C可通过交叉检验获得，控制bias-variance权衡
- 只有边界内观察点影响超平面的选择，这些点为支持向量，是形成模型的关键
- 与LDA不同，使用部分数据，与logistic回归类似

### 支持向量机原理

- 非线性条件下可以考虑将超平面理解为非线性超平面，提高样本维度换取分类效果
- 加入多项式等非线性描述后计算量不可控
- 支持向量机通过核来控制非线性边界
- 通过样本内积来解决支持向量分类问题
- 线性支持向量分类器$f(x) = \beta_0 + \sum_{i = 1}^{n} \alpha_i < x,x_i >$ 只有支持向量在解中非0，现在只需要支持向量的内积就可以求解
- 内积可以推广为核函数，核函数可以采用非线性模式
- $f(x) = \beta_0 + \sum_{i = 1}^{n} \alpha_i K( x,x_i )$ 径向基核函数较为常用
- 使用内积的核函数计算上简单且等价与高维空间超平面分类

#### 多于二分类

- 一对一分类：对比$K \choose 2$个分类器在检验集中的效果，通过计数来选择分类结果
- 一对多分类：对比K个与剩下的K-1个分类，分类结果最远的认为属于那个分类

### svm与logistic回归关系

- 中枢损失，对关键点敏感
- 传统方法也可以借鉴核函数观点视同
- 支持向量无法提供参数概率信息，采用核函数的logistic回归可以，计算量大
- 分类距离较远，支持向量机会比logistic回归好一点
- 支持向量机是计算机背景，logistic回归是概率背景

## 无监督学习

### 主成分分析

- 用较少的变量代表较多的变量，方便可视化与理解数据
- 第一主成分$Z_1 = \phi_{11} X_1 + \phi_{21}X_2 + ... + \phi_{p1} X_p$ 方差最大， 正则化后有$\sum_{j = 1}^p \phi_{j1}^2 = 1$，则$\phi$为变量在第一主成分上的载荷
- 求解上第一主成分最大化$\frac{1}{n} \sum_{i = 1}^{n} z_{i1}^2$ 求解载荷值，$z_{ni}$是第一个样本在第一个主成分上的得分
- 载荷表示变量重要程度，得分表示样本重要程度
- 第二主成分与第一主成分正交求解
- biplot 同时表示载荷与得分，载荷向量接近表示有相关性，方向不一表示相关性弱，变量在主成分得分差异表示其状态
- 第一个主成分表示在p维空间里距离n个观察最近的超平面，因此具备代表性
- 取M个主成分可代表所有数据$x_{ij} \approx  \sum_{m = 1}^M z_{im} \phi_{jm}$
- 变量单位要统一，已经统一就不要标准化了
- 主成分是唯一的，符号可能有变化，载荷与得分值也唯一
- 主成分的重要性通过方差解释比例(PVE)来衡量，用碎石图来可视化$$\frac{\sum_{i = 1}^n (\sum_{j =1}^p \phi_{jm} x_{ij})^2}{\sum_{j =1}^p x_{ij}^2}$$
- 寻找碎石图的肘部来确定选取主成分的个数，方法不固定
- 可用来进行M小于p的主成分回归
- [SVD 算法](https://github.com/j2kun/svd)

### 聚类方法

- 寻找子分类或簇的方法，从异质性寻找同质性

#### k均值聚类

- 子类中方差小，子类间方差大
- 事先指定子类个数
- 最小化所有K个平均欧式距离$W(C_k) = \frac{1}{|C_k|} \sum_{i,i' \in C_k} \sum_{j = 1}^{p} (x_{ij} - x_{i'j})^2$
- 先对所有样本随机分类，然后每种分类取中心，选取里中心距离最近的点重新分类，重新计算中心，迭代得到聚类结果

#### 分层聚类

- 不需要指定先前聚类数，形成冰柱图
- 冰柱图要垂直分层解释，水平解释容易出现误导- 修剪冰柱图可给出聚类数
- 计算所有样本间距离，越相近就融合为一类，重新计算距离，反复这一过程
- 计算两者间相似度是很关键的，不同场景应用不同算法
- 变量的标准化处理上也很重要，考虑实际场景

## 人工神经网络

- [RNN神经网络算法](http://karpathy.github.io/2015/05/21/rnn-effectiveness/)
- [LSTM神经网络算法](http://livefreeordichotomize.com/2017/11/08/lstm-neural-nets-as-told-by-baseball/)
- [tensorflow keras与深度学习](https://rstd.io/ml-with-tensorflow-and-r/)
- [通过正交变量监督黑箱模型的敏感度](http://blog.fastforwardlabs.com/2017/03/09/fairml-auditing-black-box-predictive-models.html)

## 模型联合

- 通过平均与投票结合模型
- 联合分类器提高准确率
- `caretEnsemble` 包
- 案例 广义加性模型

```
library(ISLR); data(Wage); library(ggplot2); library(caret);
Wage <- subset(Wage,select=-c(logwage))
# Create a building data set and validation set
inBuild <- createDataPartition(y=Wage$wage,p=0.7, list=FALSE)
validation <- Wage[-inBuild,]; buildData <- Wage[inBuild,]
inTrain <- createDataPartition(y=buildData$wage,p=0.7, list=FALSE)
training <- buildData[inTrain,]; testing <- buildData[-inTrain,]
mod1 <- train(wage ~.,method="glm",data=training)
mod2 <- train(wage ~.,method="rf",data=training,trControl = trainControl(method="cv"),number=3)
pred1 <- predict(mod1,testing); pred2 <- predict(mod2,testing)
qplot(pred1,pred2,colour=wage,data=testing)
predDF <- data.frame(pred1,pred2,wage=testing$wage)
combModFit <- train(wage ~.,method="gam",data=predDF)
combPred <- predict(combModFit,predDF)
sqrt(sum((pred1-testing$wage)^2))
sqrt(sum((pred2-testing$wage)^2))
sqrt(sum((combPred-testing$wage)^2))
```

## 无监督预测

- 先聚类 后预测
- `clue` 包 `cl_predict` 函数
- 推荐系统

## 模型预测

- 时序数据 包含趋势 季节变化 循环
  - 效应分解 `decompose`
  - `window` 窗口
  - `ma` 平滑
  - `ets` 指数平滑
  - `forecast` 预测
- 空间数据同样有这种问题 临近依赖 地域效应
- `quantmod` 包 或 `quandl` 包处理金融数据 
- 外推要谨慎

## 模型可视化

- [统计模型可视化](http://mfviz.com/hierarchical-models/)
